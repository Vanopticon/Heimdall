# Feature: M4-T4.2 -> Integration & E2E Test Harness

## Related Items

- See: `docs/design/features/OBS-001-Observability-Testing.md`
- See: `docs/TESTING.md`

## Story

As a developer, I want a robust integration and end-to-end test harness that validates complete workflows against ephemeral Postgres+AGE instances, so that I can confidently deploy changes without breaking core functionality.

## Overview

This feature provides:

- **Test harness infrastructure**: Docker-based ephemeral Postgres+AGE database for integration tests
- **Example integration tests**: Covering ingest, enrichment mocking, and sync partition scenarios
- **CI integration**: GitHub Actions workflow to run integration tests in CI
- **Documentation**: Comprehensive guide for running tests locally and writing new integration tests

## Implementation Details

### Test Harness Components

**Docker Manager** (`src/devops/docker_manager.rs`):
- `start_dev_db()`: Programmatically start Postgres+AGE via docker-compose
- `stop_dev_db()`: Clean up Docker containers
- Marker file tracking to avoid stopping externally-managed databases

**Helper Scripts** (`docker/scripts/`):
- `start-postgres.sh`: Shell script alternative for starting database
- `stop-postgres.sh`: Shell script for stopping database

**Docker Compose** (`docker/docker-compose.yml`):
- Postgres+AGE+pgvector image definition
- Automatic extension initialization via `docker/postgres-age/initdb/`

### Example Integration Tests

**Basic Database Operations** (`tests/integration_dev_db.rs`):
- Database connectivity verification
- AGE client merge operations

**End-to-End NDJSON Workflow** (`tests/integration_e2e.rs`):
- Upload NDJSON data
- Verify nodes persisted in graph
- Full ingest → persist → verify cycle

**Enrichment Mock Workflow** (`tests/integration_enrichment_mock.rs`):
- Mock enrichment data (GeoIP, ASN, DNS)
- Verify enrichment nodes in graph
- Chained enrichment scenarios (domain → DNS → IP → GeoIP)

**Sync Partition Tests** (`tests/integration_sync_partition.rs`):
- Multi-instance data partitioning
- Cross-instance synchronization
- Deduplication during sync

### CI Integration

**GitHub Actions Workflow** (`.github/workflows/integration-tests.yml`):
- Runs on PRs and pushes to main/v1.0.0
- Sets `RUN_DOCKER_INTEGRATION_TESTS=1` environment variable
- Executes all integration test suites
- Automatic Docker cleanup

### Documentation

**Testing Guide** (`docs/TESTING.md`):
- Overview of test structure and categories
- Running integration tests locally
- Writing new integration tests
- Troubleshooting common issues
- Database schema and extensions

## Acceptance Criteria

- [x] CI runs integration/e2e tests against ephemeral Postgres+AGE and reports results
- [x] Local `cargo test --features integration-tests` runs successfully with `RUN_DOCKER_INTEGRATION_TESTS=1`
- [x] Example integration tests cover:
  - [x] Ingest NDJSON → verify graph nodes
  - [x] Enrichment mocking → verify enrichment nodes (2 test scenarios)
  - [x] Sync partition test (2 test scenarios)
- [x] Documentation for local test runs and test helpers
- [x] Docker compose helpers for running tests locally

## Usage Examples

### Running Integration Tests Locally

```bash
# Enable integration tests
export RUN_DOCKER_INTEGRATION_TESTS=1

# Run all integration tests
cargo test --features integration-tests

# Run specific test suite
cargo test --features integration-tests --test integration_enrichment_mock

# Run with output visible
cargo test --features integration-tests -- --nocapture
```

### Running via CI

Integration tests run automatically in GitHub Actions when:
- PRs are opened or updated against main or v1.0.0
- Commits are pushed to main or v1.0.0

### Writing New Integration Tests

```rust
use std::env;

#[tokio::test]
async fn my_integration_test() {
    // Gate the test
    if env::var("RUN_DOCKER_INTEGRATION_TESTS").is_err() {
        eprintln!("Skipping; set RUN_DOCKER_INTEGRATION_TESTS=1");
        return;
    }

    // Start database
    vanopticon_heimdall::devops::start_dev_db()
        .await
        .expect("start db");

    // Test logic here...

    // Cleanup
    vanopticon_heimdall::devops::stop_dev_db()
        .await
        .expect("stop db");
}
```

## Testing This Feature

All integration tests are located in the `tests/` directory:

```bash
# Verify all tests compile
cargo test --features integration-tests --no-run

# Run all integration tests (requires Docker)
export RUN_DOCKER_INTEGRATION_TESTS=1
cargo test --features integration-tests

# Check specific test files
cargo test --features integration-tests --test integration_dev_db
cargo test --features integration-tests --test integration_e2e
cargo test --features integration-tests --test integration_enrichment_mock
cargo test --features integration-tests --test integration_sync_partition
```

## Notes

- Integration tests are gated by the `RUN_DOCKER_INTEGRATION_TESTS` environment variable to avoid running Docker in environments where it's unavailable
- The test harness uses a marker file (`.heimdall_db_started`) to track containers started by tests
- Each test manages its own database lifecycle (start → test → stop)
- Tests wait for database readiness before proceeding with test logic
- The CI workflow includes automatic Docker cleanup to prevent resource leaks

## Future Enhancements

- Add testcontainers-rs support for more flexible container management
- Implement test data fixtures and helpers
- Add performance benchmarks for integration scenarios
- Create test coverage reports for integration paths
- Add network isolation tests for multi-instance sync scenarios
